# Linux 进程调度算法

1. CPU/IO消耗型进程
2. 吞吐率 vs. 响应
3. SCHED_FIFO、 SCHED_RR
4. SCHED_NORMAL和CFS
5. nice、 renice
6. chrt

练习题：

1. 运行 2 个高 CPU 利用率进程，调整他们的 nice
2. 用 chrt 把一个死循环进程调整为 SCHED_FIFO
3. 阅读 ARM 的 big.LITTLE 架构资料

## 1. 吞吐率 vs. 响应

Linux 调度算法的设计目标是满足 2 个指标：吞吐量与响应。这两个指标
是矛盾的，一个指标的上升必然影响到另一个指标的性能。从用户的角度来
看，吞吐量是完成所有工作负载花费时间最少，响应是指处理任务时响应时间
最短。简单地说就是 linux 在单位时间内切换任务的次数越多，响应任务的时
间越快，但由于切换任务所需的上下文开销（上下文切换会引起大量的 cache miss
所以很浪费时间。局部性被打乱了，包括时间和空间的局部性），会导致吞吐量的下降。
根据不同的应用场景，我们会选择不同的算法来达到这两个指标的平衡。

一个系统设计的时候会考虑： 吞吐量大，响应快

![吞吐 vs. 响应][1]

内核抢占选项,可以分为3个选项，手机/嵌入式选择第三种抢占方式，这里介绍第三种

- ( ) No Forced Preemption (Server) -- 都不能强
- (X) Voluntary Kernel Preemption (Desktop) -- 内核不能强
- ( ) Preemptible Kernel (Low-Latency Desktop) -- 低延迟，在内核也要强占  

![内核抢占选项][2]

## 2. CPU/IO消耗型进程

- **CPU 消耗型**是指 CPU 占用率高的应用，比如编译代码。
- **IO 消耗型**指像读硬盘之类的应用，大部分时间消耗在 DMA 上， CPU 占用率比较低。

典型的操作系统内， **IO 消耗型的优先级比较高**。因为 IO 消耗型应用往往与用户体验密
切相关，比如读写硬盘和外设之类的操作，用户操作键盘和鼠标时如果长时间
没有反应，就会导致体验很差。而 CPU 消耗型，比如编译程序，我们可以把它
的优先级降低，编译时间从 10 分钟变成 11 分钟，对用户的体验影响不是很大。

IO 型对 CPU 的 **强弱不敏感**，对 **何时** 抢到 CPU 特敏感。因为处理时间多数花
费在非 CPU 的计算上， CPU 处理占用的比例很小，因此 CPU 的强弱对 IO 消
耗影响不大。

### ARM 的 **big.LITTLE** 设计

![ARM big.LITTLE][3]

从用户体验上， CPU 运算能力越快越好，但 CPU 能力越强，功耗也越大。
为了实现处理相同任务花费的时间和功耗更低的目标， arm 采用了大核加小核
的设计模式。大核 CPU 运算力强，功耗高，小核 CPU 运算力弱，功耗低。 CPU
调度算法根据 CPU 消耗型和 IO 消耗型的特点来分配任务到不同的核上来实
现低功耗和高性能的目标。

ARM **big.LITTLE** 设计，假如一个 8 核的 CPU 则，4个大的和4个小。
采用大核 + 小核的设计，大核功耗高，运算力强，用于处理 CPU 消耗性任务，小核功耗低，
功耗小，用于处理 I/O 消耗性任务。实现功耗降低，但处理效果与全是大核处理一致的效果

## 3. Linux 调度器

Linux 调度进程时主要考虑两个要素：策略和优先级。Linux 所有的优先级分成 0-139，其中 0-99 为 RT 进程，
100-139 对应普通进程（nice 值 -20 到 19）。数字越小优先级越高。

![早期2.6:优先级数组和Bitmaps][4]

### RT 进程

RT 进程 : SCHED_FIFO 和 SCHED_RR 两种。

- **SCHED_FIFO** 不同优先级按照优先级高的先跑到睡眠，优先级低的再跑；同等优先级先进先出。
- **SCHED_RR** RR 的含义是 round-robin， 不同优先级按照优先级高的先跑到睡眠，优先级低的再跑； 同等优先级轮转。

CHED_FIFO 和 SCHED_RR 在不同优先级上表现完全一样。区别在于同等优先级的调度上， SCHED_FIFO 策略对应的进程会一直跑到睡眠才轮转到其它同等优先级的 RT 进程运行。 SCHED_RR 会根据时间片进行轮转。

这些调度都是基于 task_struct 调度的，每一个都是可以通过 API 进行设置的：

![调度相关的系统调用][5]

RT 进程没有 nice 值, 执行自己的调度算法。
RT 进程和普通进程的调度区别如下：

1. RT 进程优先级高的进程未睡眠，优先级低的进程无法抢占。
2. 普通进程优先级低的进程也可以抢占高优先级的普通进程，区别在于抢到的 CPU 时间会比较少。

![示例设置调度][6]

### NORMAL 进程

NORMAL 进程根据自己的 nice 值采用相应的算法进行调度。

Linux 2.6 之前执行优先级与 nice 值相关， nice 值随进程睡的时间动态相关，普
通 NORMAL 进程的 nice 值执行动态变化的策略，睡得越久，优先级越高。
2.6 之后增加了 2 个补丁： 熔断机制补丁和 CFS 调度算法。

1. 熔断补丁： 限制了 RT 进程和 NORMAL 进程的比例，当 RT 进程一直占用CPU 到了熔断阈值的时刻，强制调度让 NORMAL 进程运行。
2. CFS 调度算法： 改进了 NORMAL 进程的调度算法，采用红黑树实现完全

FIFO 和 RR 不睡，普通进程是没法运行的。所以限制 RT 进程的运行时间，默认运行0.95S，让普通进程也可以运行，
运行时间可以通过 RT 门限进行配置，即熔断机制
![RT 门限][7]

NORMAL 进程调度 ： 公平的调度策略
![CFS 调度算法][8]

Linux 2.6 早期版本优先级不完全取决于代码中设置的进程 nice 值， nice 值
设置之后还会对普通进程进行一个评估，其优先级是动态调整的。评估标准是
睡眠越久，优先级越高。优先级是随着睡眠时间的增加而增加，占用 CPU 的
时间越长，优先级会随着降低。此算法的缺点是进程干活越久优先级越低，会
导致经常处理任务的进程优先级越来越低，干的活越来越少。之后加入的补丁
引入了 CFS 算法修正了这个缺陷。
CFS(Completely Fair Scheduler) 完合公平调度指的是保证所有 NORMAL
进程 (task_struct) 虚拟运行时间完全相同。其虚拟运行时间的计算公式为

    vtime = ptime ∗ 1024/weight
    vtime : 虚拟运行时间
    ptime : 指进程运行物理时间
    1024 : 系数
    weight : 权重，由 nice 值决定。

所有 **虚拟时间挂在红黑树** 上，每次 linux 调度虚拟时间最小的进程运行。

虚拟运行时间是通过 weight 确定，也是通过 nice 值确定， nice 值越小 weight越大，
虚拟运行时间也就越小，越容易强到 CPU 运行。

![weight & nice][9]

## 4. Linux 修改进程优先级

调度优先级是内核分配给进程的代表执行先后可能的整数 (-20-19) 整数值越
小，优先级越高。 bash shell 默认以优先级 0 来启动所有进程，可通过 nice 命令
和 renice 调整。可以通过 **man** 命令查看帮助

![运行是调整优先级][10]

### nice -- 启动时指定

对于普通用户来说，只可以以更低优先级运行命令，更高优先级运行命令
需要高级用户权限。 nice 命令是为未运行命令指定运行时调度优先级的，如果
是已运行的命令则需要 renice 命令
    # 以 10 优先级值后台运行 httpd 命令
    nice -n 10 httpd &
    -n 后面整数指定 httpd 命令运行的优先级
    httpd 即要改变优先级的命令
    & 表示此命令为后台运行

### renice -- 启动后更改

renice 命令与 nice 命令用法一样，限制也一样（普通用户只能以更低的调
度优先级运行命令），惟一不同就是可以更新正在运行命令的调度优先级。
    参数含义
    -g 使用程序群组名称，修改所有隶属于该程序群组的程序的优先权。
    -p 改变该程序的优先权等级，此参数为预设值。
    -u 指定用户名称，修改所有隶属于该用户的程序的优先权。

### chrt -- 设置一个进程为 RT

使用实时调度策略，必须具有 root 权限。 chrt 命令的策略选项
    #chrt 参数含义
    短选项 长选项 詳細
    -f –fifo 调度器设成 SCHED_FIFO
    -o –other 调度器设成 SCHED_OTHER
    -r –rr 调度器设成 SCHED_RR
    -a –all-tasks 设置 Pid 号对应的所有线程

    chrt 使用方法
    # 确认某个进程的属性可以通过指定 -p 或 --pid 并指定进程 ID，用法如下：
    # chrt -p 468
    pid 468’s current scheduling policy: SCHED_FIFO
    pid 468’s current scheduling priority: 85
    # chrt -p 476
    pid 476’s current scheduling policy: SCHED_OTHER
    pid 476’s current scheduling priority: 0
    # 将 PID 1000 的进程设定成 SCHED_FIFO，优先级设定成 50。
    chrt -f -p 50 1000
    # 将 PID 1000 的进程设定成 SCHED_OTHER，优先级设定成 0。
    chrt -o -p 0 1000
    # 起动 /bin/my-app 设定成 SCHED_FIFO，优先级设定成 36。
    chrt -f 36 /bin/my-app

## 5. 进程运行

程序运行时大部分进程状态为运行或睡眠。调度算法解决可以跑的运行状态
（就绪和运行），剩下的不可以跑的进程就是睡眠和等待。睡眠实现对应的代码
就是调用了 schdule 函数，唤醒则是对应的是 schdule 返回。一个进程等资源就
会去睡， linux 所有的睡眠，对应的 task_struct 就会挂在队列 wait_queue 上，当
资源来了后，就会唤醒等待队列上的进程。

[1]: images/3_01.jpg "吞吐 vs. 响应"
[2]: images/3_02.jpg "内核抢占选项"
[3]: images/3_03.jpg "ARM big.LITTLE"
[4]: images/3_04.jpg "早期2.6:优先级数组和Bitmaps"
[5]: images/3_05.jpg "调度相关的系统调用"
[6]: images/3_06.jpg "示例设置调度"
[7]: images/3_07.jpg "RT 门限"
[8]: images/3_08.jpg "CFS 调度算法"
[9]: images/3_09.jpg "weight & nice"
[10]: images/3_10.jpg "运行是调整优先级"